# 操作系统上的程序
- [操作系统上的程序 (什么是程序和编译器) [南京大学2022操作系统-P2]](https://www.bilibili.com/video/BV12L4y1379V?spm_id_from=333.788.videopod.sections&vd_source=b3d4057adb36b9b243dc8d7a6fc41295)
- https://jyywiki.cn/OS/2022/index.html

## 程序就是状态机


## 源代码视角： 状态 =  堆 +  栈

- 状态 =  堆 +  栈
  stack frame 的列表 :  main frame -> hanoi(3,...) frame -> hanoi(2,...) frame ->...
  ```bash
  (gdb) info stack
    #0  hanoi (n=2, from=65 'A', to=67 'C', via=66 'B') at hanoi-r.c:4
    #1  0x00005555555551c9 in hanoi (n=3, from=65 'A', to=66 'B', via=67 'C') at hanoi-r.c:6
    #2  0x000055555555516a in main () at main.c:6
  ```

- 初始状态： 
  main(argc, argv) 的第一条语句, 全局变量初始化

- 迁移： 执行 top stack frame PC 的语句; PC++
  函数调用：  push frame
  函数返回：  pop frame

### 应用： 将任何递归程序转换为非递归 


## 二进制视角：  状态 = 内存 + 寄存器

- 状态 = 内存 + 寄存器
- 初始状态 = 

- 迁移： 执行一条指令
  - 计算指令
  - syscall 指令


### syscall 特殊指令

实现与操作系统中的其他对象的交互
-  读写文件
-  读写操作系统状态
-  改变进程的状态，比如创建进程和销毁

## Examples
### hanoi example
```bash
# from https://jyywiki.cn/OS/2022/notes/1.html
wget https://jyywiki.cn/pages/OS/2022/demos/hanoi-nr.c

cd code_example/process
ls

# by default gcc does not include debugging symbols. That’s why GDB says (No debugging symbols found in a.out) and why layout src shows you an empty window.
gcc -g -O0 -Wall -Wextra -Werror main.c hanoi-r.c && ./a.out
# -g tells GCC to include source line information in the binary. Without it, you only get raw machine instructions.
# --O0: Disable optimizations so the compiled code matches your source more closely:


# run gdb
gdb a.out

Reading symbols from a.out...
(No debugging symbols found in a.out)

(gdb) layout src
(gdb) start
Temporary breakpoint 1 at 0x11d5: file main.c, line 5.
Starting program: /mnt/e/projects/operating_system/code_examples/src/process/a.out

Temporary breakpoint 1, main () at main.c:5

# where: Shows the current call stack and highlights the current line of execution.
(gdb) where
#0  main () at main.c:6

(gdb) info stack
#0  main () at main.c:6

(gdb) info frame
# Stack level 0, frame at 0x7fffffffd970:
#  rip = 0x5555555551dd in main (main.c:6); saved rip = 0x7ffff7dec083
#  source language c.
#  Arglist at 0x7fffffffd958, args: 
#  Locals at 0x7fffffffd958, Previous frame's sp is 0x7fffffffd970
#  Saved registers:
#   rbp at 0x7fffffffd960, rip at 0x7fffffffd968

(gdb) s
6               hanoi(3,'A','B','C');

(gdb) s
hanoi (n=21845, from=96 '`', to=0 '\000', via=0 '\000') at hanoi-r.c:3
(gdb) s

(gdb) info stack
#0  hanoi (n=3, from=65 'A', to=66 'B', via=67 'C') at hanoi-r.c:4
#1  0x000055555555516a in main () at main.c:6


(gdb) info frame
# Stack level 0, frame at 0x7fffffffd960:
#  rip = 0x55555555518d in hanoi (hanoi-r.c:4); saved rip = 0x55555555516a
#  called by frame at 0x7fffffffd970
#  source language c.
#  Arglist at 0x7fffffffd938, args: n=3, from=65 'A', to=66 'B', via=67 'C'
#  Locals at 0x7fffffffd938, Previous frame's sp is 0x7fffffffd960
#  Saved registers:
#   rbp at 0x7fffffffd950, rip at 0x7fffffffd958
(gdb) n
(gdb) s
hanoi (n=21845, from=77 'M', to=-1 '\377', via=70 'F') at hanoi-r.c:3

(gdb) info stack
#0  hanoi (n=2, from=65 'A', to=67 'C', via=66 'B') at hanoi-r.c:4
#1  0x00005555555551c9 in hanoi (n=3, from=65 'A', to=66 'B', via=67 'C') at hanoi-r.c:6
#2  0x000055555555516a in main () at main.c:6

(gdb) info frame
# Stack level 0, frame at 0x7fffffffd940:
#  rip = 0x55555555518d in hanoi (hanoi-r.c:4); saved rip = 0x5555555551c9
#  called by frame at 0x7fffffffd960
#  source language c.
#  Arglist at 0x7fffffffd918, args: n=2, from=65 'A', to=67 'C', via=66 'B'
#  Locals at 0x7fffffffd918, Previous frame's sp is 0x7fffffffd940
#  Saved registers:
#   rbp at 0x7fffffffd930, rip at 0x7fffffffd938
```



### Eaxample: hanoi-nr.c


main.c
```bash
#include <stdio.h>
#include "hanoi-nr.c"

int main(){
	hanoi(3,'A','B','C');
	return 0;
}

# 编译
gcc -g -O0 main.c && ./a.out
# gdb
gdb a.out

(gdb) p stk[0]
$16 = {pc = 1, n = 3, from = 65 'A', to = 66 'B', via = 67 'C'}

(gdb) p stk[1]
$15 = {pc = 0, n = 2, from = 65 'A', to = 67 'C', via = 66 'B'}

```

### 构造最小的 Hello World


#### hello.c
```c
#include <stdio.h>
#include <unistd.h>

void main(){
    printf("hello world \n");
}

// 获取汇编代码
objdump -d hello > hello.o


// --verbose: 显示编译过程
// --static: 会复制libc 
$ gcc --verbose hello.c -o hello && ./hello

Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper
OFFLOAD_TARGET_NAMES=nvptx-none:hsa
OFFLOAD_TARGET_DEFAULT=1
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion='Ubuntu 9.4.0-1ubuntu1~20.04.2' --with-bugurl=file:///usr/share/doc/gcc-9/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,gm2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-9 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-9-9QDOt0/gcc-9-9.4.0/debian/tmp-nvptx/usr,hsa --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.2) 
COLLECT_GCC_OPTIONS='-v' '-o' 'hello' '-mtune=generic' '-march=x86-64'
 /usr/lib/gcc/x86_64-linux-gnu/9/cc1 -quiet -v -imultiarch x86_64-linux-gnu hello.c -quiet -dumpbase hello.c -mtune=generic -march=x86-64 -auxbase hello -version -fasynchronous-unwind-tables -fstack-protector-strong -Wformat -Wformat-security -fstack-clash-protection -fcf-protection -o /tmp/ccyFdq1V.s
GNU C17 (Ubuntu 9.4.0-1ubuntu1~20.04.2) version 9.4.0 (x86_64-linux-gnu)
        compiled by GNU C version 9.4.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.22.1-GMP

GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
ignoring nonexistent directory "/usr/local/include/x86_64-linux-gnu"
ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/9/include-fixed"
ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/9/../../../../x86_64-linux-gnu/include"
#include "..." search starts here:
#include <...> search starts here:
 /usr/lib/gcc/x86_64-linux-gnu/9/include
 /usr/local/include
 /usr/include/x86_64-linux-gnu
 /usr/include
End of search list.
GNU C17 (Ubuntu 9.4.0-1ubuntu1~20.04.2) version 9.4.0 (x86_64-linux-gnu)
        compiled by GNU C version 9.4.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.22.1-GMP

GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
Compiler executable checksum: 01da938ff5dc2163489aa33cb3b747a7
COLLECT_GCC_OPTIONS='-v' '-o' 'hello' '-mtune=generic' '-march=x86-64'
 as -v --64 -o /tmp/ccQ5KUFS.o /tmp/ccyFdq1V.s
GNU assembler version 2.34 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.34
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/9/:/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/9/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/9/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS='-v' '-o' 'hello' '-mtune=generic' '-march=x86-64'
 /usr/lib/gcc/x86_64-linux-gnu/9/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/9/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper -plugin-opt=-fresolution=/tmp/ccUqOvzU.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -pie -z now -z relro -o hello /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/Scrt1.o /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/9/crtbeginS.o -L/usr/lib/gcc/x86_64-linux-gnu/9 -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/9/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/9/../../.. /tmp/ccQ5KUFS.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/x86_64-linux-gnu/9/crtendS.o /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/crtn.o
COLLECT_GCC_OPTIONS='-v' '-o' 'hello' '-mtune=generic' '-march=x86-64'
hello world 


```

#### minimal.S
Idea: 使用 syscall 函数调用系统调用。

```bash
wget https://jyywiki.cn/pages/OS/2022/demos/minimal.S
# minimal.S
  movq $SYS_exit,  %rax   // exit(
  movq $1,         %rdi   //   status=1
  syscall                 // );

# gcc -c minimal.S ：将汇编源文件minimal.S编译成目标文件minimal.o
# ld minimal.o：将目标文件minimal.o链接成可执行文件
gcc -g -c minimal.S  && ld minimal.o

$ ./a.out 
Hello, OS World



$ gdb a.out
(gdb) layout asm

(gdb) starti
Starting program: /mnt/e/projects/operating_system/code_examples/src/process/a.out 

Program stopped.
_start () at minimal.S:5
5         movq $SYS_write, %rax   // write(

(gdb) si
(gdb) si
(gdb) si
Hello, OS World
(gdb) si
(gdb) si
(gdb) si
[Inferior 1 (process 13449) exited with code 01]

```


### logisim
```bash
gcc logisim.c -o logisim -static
./logisim
```

## ANSI Escape Code
为什么 helloworld 有颜色？

telnet towel.blinkenlights.nl

- show a message box
sudo apt install dialog
dialog --msgbox "Hello OS" 8 32^C

- game
  ssh sshtron.zachlatta.com


## 什么编译器

编译器： 源代码 S -> 二进制代码 C
C = compile(S)

编译的正确性 soundness: S 与 C 的可观测行为严格一致

编译优化：  在保证观察一致性（soundness）de的前提下改下代码


## 操作系统

- 操作系统收编了所有的硬件和软件资源
- 只能用操作系统允许的方式访问操作系统中的对象
- 操作系统提供API 打开、读取、改写（都需要相应的权限）

## 系统中的应用程序

### Core Utilities(coreuitls)
- starndard programs for text and file manipulation
- GNU coreutils

### 系统/工具程序
-  bash
-  binutils
-  apt
-  ip
-  ssh
-  vim
-  tmux
-  jdk
-  python

### 其他应用程序
- 浏览器
- 播放器

## 操作系统面试题

### 运行 hello world.c 程序执行的第一条指令在哪里？

```bash
gcc -g hello.c && ./a.out
gdb a.out
Reading symbols from a.out...

# /lib64/ld-linux-x86-64.so.2 加载器会加载 libc, 
# libc 会运行 _start 函数
(gdb) starti
Starting program: /mnt/e/projects/operating_system/code_examples/src/process/a.out 

Program stopped.
0x00007ffff7fd0100 in _start () from /lib64/ld-linux-x86-64.so.2

# 打印进程内存
(gdb) info proc mapping
process 26302
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      0x555555554000     0x555555555000     0x1000        0x0 /mnt/e/projects/operating_system/code_examples/src/process/a.out
      0x555555555000     0x555555556000     0x1000     0x1000 /mnt/e/projects/operating_system/code_examples/src/process/a.out
      0x555555556000     0x555555557000     0x1000     0x2000 /mnt/e/projects/operating_system/code_examples/src/process/a.out
      0x555555557000     0x555555559000     0x2000     0x2000 /mnt/e/projects/operating_system/code_examples/src/process/a.out
      0x7ffff7fc9000     0x7ffff7fcd000     0x4000        0x0 [vvar]
      0x7ffff7fcd000     0x7ffff7fcf000     0x2000        0x0 [vdso]
      0x7ffff7fcf000     0x7ffff7fd0000     0x1000        0x0 /usr/lib/x86_64-linux-gnu/ld-2.31.so
      0x7ffff7fd0000     0x7ffff7ff3000    0x23000     0x1000 /usr/lib/x86_64-linux-gnu/ld-2.31.so
      0x7ffff7ff3000     0x7ffff7ffb000     0x8000    0x24000 /usr/lib/x86_64-linux-gnu/ld-2.31.so
      0x7ffff7ffc000     0x7ffff7ffe000     0x2000    0x2c000 /usr/lib/x86_64-linux-gnu/ld-2.31.so
      0x7ffff7ffe000     0x7ffff7fff000     0x1000        0x0 
      0x7ffffffdd000     0x7ffffffff000    0x22000        0x0 [stack]
```

### main函数 执行之前，执行中，执行后发生了哪些操作系统 API 调用？


#### 程序 = 状态机 = 计算 -> syscall -> 计算 -> 

被操作系统加载： 通过另外一个进程执行 execve 设置为初始状态
状态机执行：
- 进程管理： fork,execve,exit
- 文件管理： open,close,read,write, ...
- 存储管理： mmap, brk,...
直到 _exit(exit_group) 推出



#### 工具 strace 运行程序
```bash
strace ./a.out
execve("./a.out", ["./a.out"], 0x7ffc8af24030 /* 42 vars */) = 0
brk(NULL)                               = 0x5622cd80e000
arch_prctl(0x3001 /* ARCH_??? */, 0x7ffd07c820f0) = -1 EINVAL (Invalid argument)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=51576, ...}) = 0
mmap(NULL, 51576, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fced7ad4000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\300A\2\0\0\0\0\0"..., 832) = 832
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
pread64(3, "\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0", 32, 848) = 32
pread64(3, "\4\0\0\0\24\0\0\0\3\0\0\0GNU\0W\222s/x1X\306o\264\363udX\312$"..., 68, 880) = 68
fstat(3, {st_mode=S_IFREG|0755, st_size=2029592, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fced7ad2000
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
pread64(3, "\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0", 32, 848) = 32
pread64(3, "\4\0\0\0\24\0\0\0\3\0\0\0GNU\0W\222s/x1X\306o\264\363udX\312$"..., 68, 880) = 68
mmap(NULL, 2037344, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fced78e0000
mmap(0x7fced7902000, 1540096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x22000) = 0x7fced7902000
mmap(0x7fced7a7a000, 319488, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19a000) = 0x7fced7a7a000
mmap(0x7fced7ac8000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7fced7ac8000
mmap(0x7fced7ace000, 13920, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fced7ace000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7fced7ad3540) = 0
mprotect(0x7fced7ac8000, 16384, PROT_READ) = 0
mprotect(0x5622b933e000, 4096, PROT_READ) = 0
mprotect(0x7fced7b0e000, 4096, PROT_READ) = 0
munmap(0x7fced7ad4000, 51576)           = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x9), ...}) = 0
brk(NULL)                               = 0x5622cd80e000
brk(0x5622cd82f000)                     = 0x5622cd82f000
write(1, "hello world \n", 13hello world 
)          = 13
exit_group(13)                          = ?
+++ exited with 13 +++

```


### strace gcc 编译过程
```bash
# 通过管道给 vim 编辑器
# strace -f gcc hello.c → 跟踪 gcc hello.c 进程及其子进程的系统调用，并把日志输出到 标准输出。
# strace 的输出默认写到标准错误(stderr)，而不是标准输出(stdout)。需要把 stderr 重定向到 stdout，才能通过管道传给 vim
# | vim - → 把 strace 的输出通过管道传给 vim，并且 - 告诉 vim 从 标准输入 读内容。
strace -f gcc hello.c 2>&1 | vim -

# in vim过滤
: %!grep execve

:set nowrap
# execve("/usr/bin/gcc", ["gcc", "hello.c"], 0x7ffe0afdcf90 /* 41 vars */) = 0
# [pid 32602] execve("/usr/lib/gcc/x86_64-linux-gnu/9/cc1", ["/usr/lib/gcc/x86_64-linux-gnu/9/"..., "-quiet", "-imultiarch", "x86_64-linux-gnu", "hello.c", "-quiet", "-dumpbase", "hello[pid 32602] <... execve resumed>)       = 0[pid 32603] execve("/home/michael/.vscode-server/bin/f220831ea2d946c0dcb0f3eaa480eb435a2c1260/bin/remote-cli/as", ["as", "--64", "-o", "/tmp/cchLN1Zi.o", "/tmp/ccmUNaJl.s"], 0x1bbfffe
# [pid 32603] execve("/usr/local/sbin/as", ["as", "--64", "-o", "/tmp/cchLN1Zi.o", "/tmp/ccmUNaJl.s"], 0x1bbfffe0 /* 46 vars */) = -1 ENOENT (No such file or directory)
# [pid 32603] execve("/usr/local/bin/as", ["as", "--64", "-o", "/tmp/cchLN1Zi.o", "/tmp/ccmUNaJl.s"], 0x1bbfffe0 /* 46 vars */) = -1 ENOENT (No such file or directory)[pid 32603] execve("/usr/sbin/as", ["as", "--64", "-o", "/tmp/cchLN1Zi.o", "/tmp/ccmUNaJl.s"], 0x1bbfffe0 /* 46 vars */) = -1 ENOENT (No such file or directory)
# [pid 32603] execve("/usr/bin/as", ["as", "--64", "-o", "/tmp/cchLN1Zi.o", "/tmp/ccmUNaJl.s"], 0x1bbfffe0 /* 46 vars */ <unfinished ...>
# [pid 32603] <... execve resumed>)       = 0
# [pid 32604] execve("/usr/lib/gcc/x86_64-linux-gnu/9/collect2", ["/usr/lib/gcc/x86_64-linux-gnu/9/"..., "-plugin", "/usr/lib/gcc/x86_64-linux-gnu/9/"..., "-plugin-opt=/usr/lib/gcc/x86_
# [pid 32604] <... execve resumed>)       = 0
# [pid 32605] execve("/usr/bin/ld", ["/usr/bin/ld", "-plugin", "/usr/lib/gcc/x86_64-linux-gnu/9/"..., "-plugin-opt=/usr/lib/gcc/x86_64-"..., "-plugin-opt=-fresolution=/tmp/cc"..., "-plu
# [pid 32605] <... execve resumed>)       = 0


:%!grep -v ENOENT

# 都换替换为换行
:%s/,/\r /g
execve("/usr/bin/gcc"
  ["gcc"
  "hello.c"]
  0x7ffe0afdcf90 /* 41 vars */) = 0
[pid 32602] execve("/usr/lib/gcc/x86_64-linux-gnu/9/cc1"
  ["/usr/lib/gcc/x86_64-linux-gnu/9/"...
  "-quiet"
  "-imultiarch"
  "x86_64-linux-gnu"
  "hello.c"
  "-quiet"
  "-dumpbase"
  "hello.c"
  "-mtune=generic"
  "-march=x86-64"
  "-auxbase"
  "hello"
  "-fasynchronous-unwind-tables"
  "-fstack-protector-strong"
  "-Wformat"
  "-Wformat-security"
  "-fstack-clash-protection"
  "-fcf-protection"
  "-o"
  "/tmp/ccmUNaJl.s"]
  0x1bbfffe0 /* 46 vars */ <unfinished ...>
[pid 32602] <... execve resumed>)       = 0
[pid 32603] execve("/usr/bin/as"
  ["as"
  "--64"
  "-o"
  "/tmp/cchLN1Zi.o"
  "/tmp/ccmUNaJl.s"]
  0x1bbfffe0 /* 46 vars */ <unfinished ...>
[pid 32603] <... execve resumed>)       = 0
[pid 32604] execve("/usr/lib/gcc/x86_64-linux-gnu/9/collect2"
  ["/usr/lib/gcc/x86_64-linux-gnu/9/"...
  "-plugin"
  "/usr/lib/gcc/x86_64-linux-gnu/9/"...
  "-plugin-opt=/usr/lib/gcc/x86_64-"...
  "-plugin-opt=-fresolution=/tmp/cc"...
  "-plugin-opt=-pass-through=-lgcc"
  "-plugin-opt=-pass-through=-lgcc_"...
  "-plugin-opt=-pass-through=-lc"
  "-plugin-opt=-pass-through=-lgcc"
                                     

```

### strace xedit/vscode 图形界面程序


# 操作系统上的进程
-[操作系统上的进程 (最小 Linux; fork, execve 和 exit) [南京大学2022操作系统-P11]](https://www.bilibili.com/video/BV1hL411w737?spm_id_from=333.788.videopod.sections&vd_source=b3d4057adb36b9b243dc8d7a6fc41295)
- https://jyywiki.cn/OS/2022/slides/11.slides.html#/0/1


## 定制最小的 Linux

### 系统启动到第一个进程
thread-os.c 的加载过程
CPU reset -> Firmware ->  Bootloader -> kernel _start -> OS -> init -> init process -> syscall 

### Start the minimal linux

```bash
$ wget https://box.nju.edu.cn/f/3f67e092e1ba441187d9/?dl=1
$ mv index.html\?dl\=1 linux-minimal.zip
$ unzip linux-minimal.zip
$ cd linux-minimal
$ tree
.
├── Makefile
├── initramfs
│   ├── bin
│   │   └── busybox
│   └── init
└── vmlinuz

$ make
.
./bin
./bin/busybox
./init
5873 blocks

$ tree
.
├── Makefile
├── build
│   └── initramfs.cpio.gz
├── initramfs
│   ├── bin
│   │   └── busybox
│   └── init
└── vmlinuz

$ sudo apt update
$ sudo apt install qemu-system-x86
$ which qemu-system-x86_64
/usr/bin/qemu-system-x86_64

# bin/busybox (可以在我们的Linux里直接执行)
# 加上 vmlinuz (内核镜像) 就可以在 QEMU 里启动了
$ make run
sh: can't access tty; job control turned off
/ # 

# 打开 QEMU monitor 的方法：
在运行中的 QEMU 终端里，输入快捷键 Ctrl-a c。
Ctrl-a c → 从串口切换到 QEMU monitor 界面。
再按 Ctrl-a c → 就能切回 guest 的串口终端。


/ # /bin/busybox
BusyBox v1.31.1 (2020-03-22 13:22:47 UTC) multi-call binary.
BusyBox is copyrighted by many authors between 1998-2015.
Licensed under GPLv2. See source distribution for detailed
copyright notices.

Usage: busybox [function [arguments]...]
   or: busybox --list[-full]
   or: busybox --show SCRIPT
   or: busybox --install [-s] [DIR]
   or: function [arguments]...

        BusyBox is a multi-call binary that combines many common Unix
        utilities into a single executable.  Most people will create a
        link to busybox for each function they wish to use and BusyBox
        will act like whatever it was invoked as.

Currently defined functions:
        [, [[, acpid, add-shell, addgroup, adduser, adjtimex, arch, arp,
        arping, ash, awk, base64, basename, bc, beep, blkdiscard, blkid,
        blockdev, bootchartd, brctl, bunzip2, bzcat, bzip2, cal, cat, chat,
        chattr, chgrp, chmod, chown, chpasswd, chpst, chroot, chrt, chvt,
        cksum, clear, cmp, comm, conspy, cp, cpio, crond, crontab, cryptpw,
        cttyhack, cut, date, dc, dd, deallocvt, delgroup, deluser, depmod,
        devmem, df, dhcprelay, diff, dirname, dmesg, dnsd, dnsdomainname,
        dos2unix, dpkg, dpkg-deb, du, dumpkmap, dumpleases, echo, ed, egrep,
        eject, env, envdir, envuidgid, ether-wake, expand, expr, factor,
        fakeidentd, fallocate, false, fatattr, fbset, fbsplash, fdflush,
        fdformat, fdisk, fgconsole, fgrep, find, findfs, flock, fold, free,
        freeramdisk, fsck, fsck.minix, fsfreeze, fstrim, fsync, ftpd, ftpget,
        ftpput, fuser, getopt, getty, grep, groups, gunzip, gzip, halt, hd,
        hdparm, head, hexdump, hexedit, hostid, hostname, httpd, hush, hwclock,
        i2cdetect, i2cdump, i2cget, i2cset, i2ctransfer, id, ifconfig, ifdown,
        ifenslave, ifplugd, ifup, inetd, init, insmod, install, ionice, iostat,
        ip, ipaddr, ipcalc, ipcrm, ipcs, iplink, ipneigh, iproute, iprule,
        iptunnel, kbd_mode, kill, killall, killall5, klogd, last, less, link,
        linux32, linux64, linuxrc, ln, loadfont, loadkmap, logger, login,
        logname, logread, losetup, lpd, lpq, lpr, ls, lsattr, lsmod, lsof,
        lspci, lsscsi, lsusb, lzcat, lzma, lzop, makedevs, makemime, man,
        md5sum, mdev, mesg, microcom, mkdir, mkdosfs, mke2fs, mkfifo,
        mkfs.ext2, mkfs.minix, mkfs.vfat, mknod, mkpasswd, mkswap, mktemp,
        modinfo, modprobe, more, mount, mountpoint, mpstat, mt, mv, nameif,
        nanddump, nandwrite, nbd-client, nc, netstat, nice, nl, nmeter, nohup,
        nologin, nproc, nsenter, nslookup, ntpd, nuke, od, openvt, partprobe,
        passwd, paste, patch, pgrep, pidof, ping, ping6, pipe_progress,
        pivot_root, pkill, pmap, popmaildir, poweroff, powertop, printenv,
        printf, ps, pscan, pstree, pwd, pwdx, raidautorun, rdate, rdev,
        readahead, readlink, readprofile, realpath, reboot, reformime,
        remove-shell, renice, reset, resize, resume, rev, rm, rmdir, rmmod,
        route, rpm, rpm2cpio, rtcwake, run-init, run-parts, runlevel, runsv,
        runsvdir, rx, script, scriptreplay, sed, sendmail, seq, setarch,
        setconsole, setfattr, setfont, setkeycodes, setlogcons, setpriv,
        setserial, setsid, setuidgid, sh, sha1sum, sha256sum, sha3sum,
        sha512sum, showkey, shred, shuf, slattach, sleep, smemcap, softlimit,
        sort, split, ssl_client, start-stop-daemon, stat, strings, stty, su,
        sulogin, sum, sv, svc, svlogd, svok, swapoff, swapon, switch_root,
        sync, sysctl, syslogd, tac, tail, tar, taskset, tc, tcpsvd, tee,
        telnet, telnetd, test, tftp, tftpd, time, timeout, top, touch, tr,
        traceroute, traceroute6, true, truncate, ts, tty, ttysize, tunctl,
        ubiattach, ubidetach, ubimkvol, ubirename, ubirmvol, ubirsvol,
        ubiupdatevol, udhcpc, udhcpc6, udhcpd, udpsvd, uevent, umount, uname,
        unexpand, uniq, unix2dos, unlink, unlzma, unshare, unxz, unzip, uptime,
        users, usleep, uudecode, uuencode, vconfig, vi, vlock, volname, w,
        wall, watch, watchdog, wc, wget, which, who, whoami, whois, xargs, xxd,
        xz, xzcat, yes, zcat, zcip

/ # /bin/busybox ls
bin   dev   init  root


/ # /bin/busybox find /
/
/.ash_history
/init
/bin
/bin/busybox
/root
/dev
/dev/console

```

### BusyBox: The Swiss Army Knife of embedded Linux
```bash
c1="arch ash base64 cat chattr chgrp chmod chown conspy cp cpio cttyhack date dd df dmesg dnsdomainname dumpkmap echo ed egrep false fatattr fdflush fgrep fsync getopt grep gunzip gzip hostname hush ionice iostat ipcalc kbd_mode kill link linux32 linux64 ln login ls lsattr lzop makemime mkdir mknod mktemp more mount mountpoint mpstat mt mv netstat nice nuke pidof ping ping6 pipe_progress printenv ps pwd reformime resume rev rm rmdir rpm run-parts scriptreplay sed setarch setpriv setserial sh sleep stat stty su sync tar touch true umount uname usleep vi watch zcat"
c2="[ [[ awk basename bc beep blkdiscard bunzip2 bzcat bzip2 cal chpst chrt chvt cksum clear cmp comm crontab cryptpw cut dc deallocvt diff dirname dos2unix dpkg dpkg-deb du dumpleases eject env envdir envuidgid expand expr factor fallocate fgconsole find flock fold free ftpget ftpput fuser groups hd head hexdump hexedit hostid id install ipcrm ipcs killall last less logger logname lpq lpr lsof lspci lsscsi lsusb lzcat lzma man md5sum mesg microcom mkfifo mkpasswd nc nl nmeter nohup nproc nsenter nslookup od openvt passwd paste patch pgrep pkill pmap printf pscan"
c3="pstree pwdx readlink realpath renice reset resize rpm2cpio runsv runsvdir rx script seq setfattr setkeycodes setsid setuidgid sha1sum sha256sum sha3sum sha512sum showkey shred shuf smemcap softlimit sort split ssl_client strings sum sv svc svok tac tail taskset tcpsvd tee telnet test tftp time timeout top tr traceroute traceroute6 truncate ts tty ttysize udhcpc6 udpsvd unexpand uniq unix2dos unlink unlzma unshare unxz unzip uptime users uudecode uuencode vlock volname w wall wc wget which who whoami whois xargs xxd xz xzcat yes"
for cmd in $c1 $c2 $c3; do
  /bin/busybox ln -s /bin/busybox /bin/$cmd
done
mkdir -p /proc && mount -t proc  none /proc
mkdir -p /sys  && mount -t sysfs none /sys
export PS1='(linux) '


(linux) ls
bin   dev   init  proc  root  sys



$ gcc minimal.S -g -c && ld minimal.o

$ ./a.out 
Hello, OS World

```

# 进程的地址空间

[进程的地址空间 (pmap; vdso; mmap; 游戏修改器/外挂) [南京大学2022操作系统-P12]](https://www.bilibili.com/video/BV1Er4y1q7xo?spm_id_from=333.788.videopod.sections&vd_source=b3d4057adb36b9b243dc8d7a6fc41295)



## gdb debug for minimal.S
```bash
# gcc minimal.S -c：将汇编源文件minimal.S编译成目标文件minimal.o
# ld minimal.o：将目标文件minimal.o链接成可执行文件
gcc -g -c minimal.S  && ld minimal.o

$ ./a.out 
Hello, OS World

$ strace ./a.out 
execve("./a.out", ["./a.out"], 0x7ffcf254c290 /* 42 vars */) = 0
write(1, "\33[01;31mHello, OS World\33[0m\n", 28Hello, OS World
) = 28
exit(1)                                 = ?
+++ exited with 1 +++

$ gdb a.out
Reading symbols from a.out...

(gdb) starti
Starting program: /mnt/e/projects/operating_system/code_examples/src/process/a.out 

Program stopped.
_start () at minimal.S:5
5         movq $SYS_write, %rax   // write(

(gdb) where
#0  _start () at minimal.S:5

(gdb) p/x $pc
$2 = 0x401000

(gdb) x/10i $pc
=> 0x401000 <_start>:   mov    $0x1,%rax
   0x401007 <_start+7>: mov    $0x1,%rdi
   0x40100e <_start+14>:        mov    $0x40102e,%rsi
   0x401015 <_start+21>:        mov    $0x1c,%rdx
   0x40101c <_start+28>:        syscall 
   0x40101e <_start+30>:        mov    $0x3c,%rax
   0x401025 <_start+37>:        mov    $0x1,%rdi
   0x40102c <_start+44>:        syscall 
   0x40102e <st>:       sbb    0x30(%rbx),%ebx
   0x401031 <st+3>:     xor    %edi,(%rbx)

(gdb) info inferiors
  Num  Description       Executable        
* 1    process 2756      /mnt/e/projects/operating_system/code_examples/src/process/a.out
```

## 利用pmap查看进程的地址空间

Claim: pmap 是通过访问 procfs (/proc/) 实现的



```bash
$ pmap 2756
2756:   /mnt/e/projects/operating_system/code_examples/src/process/a.out
0000000000400000      4K r---- a.out
0000000000401000      4K r-x-- a.out       # 0x401000 <_start>:   mov    $0x1,%rax
00007ffff7ff9000     16K r----   [ anon ]
00007ffff7ffd000      8K r-x--   [ anon ]
00007ffffffdd000    136K rw---   [ stack ]
 total              168K

$ strace pmap 2756 2>&1 | vim -
:set nowrap

openat(AT_FDCWD, "/proc/2756/cmdline", O_RDONLY) = 3
read(3, "/mnt/e/projects/operating_system"..., 2047) = 65
close(3)                                = 0
fstat(1, {st_mode=S_IFIFO|0600, st_size=0, ...}) = 0
openat(AT_FDCWD, "/proc/2756/maps", O_RDONLY) = 3              # /proc/2756/maps
fstat(3, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
read(3, "00400000-00401000 r--p 00000000 "..., 1024) = 517
read(3, "", 1024)                       = 0
close(3)                                = 0
write(1, "2756:   /mnt/e/projects/operatin"..., 2992756:   /mnt/e/projects/operating_system/code_examples/src/process/a.out
0000000000400000      4K r---- a.out
0000000000401000      4K r-x-- a.out
00007ffff7ff9000     16K r----   [ anon ]
00007ffff7ffd000      8K r-x--   [ anon ]
00007ffffffdd000    136K rw---   [ stack ]
 total              168K
) = 299
close(1)                                = 0


(gdb) !cat /proc/2756/maps
00400000-00401000 r--p 00000000 00:56 2814749767532925                   /mnt/e/projects/operating_system/code_examples/src/process/a.out
00401000-00402000 r-xp 00001000 00:56 2814749767532925                   /mnt/e/projects/operating_system/code_examples/src/process/a.out
7ffff7ff9000-7ffff7ffd000 r--p 00000000 00:00 0                          [vvar]
7ffff7ffd000-7ffff7fff000 r-xp 00000000 00:00 0                          [vdso]
7ffffffdd000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]


# 读 proc 手册
$ man 5 proc
/maps

```


### RTFM: /proc/[pid]/maps (man 5 proc)

进程地址空间中的每一段,TFM 里有更详细的解释
- 地址 (范围) 和权限 (rwxsp)
- 对应的文件: offset, dev, inode, pathname


## readelf

```bash
$ readelf -l a.out | less

Elf file type is EXEC (Executable file)
Entry point 0x401000
There are 2 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000000b0 0x00000000000000b0  R      0x1000
  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                 0x000000000000004a 0x000000000000004a  R E    0x1000

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .text 

```